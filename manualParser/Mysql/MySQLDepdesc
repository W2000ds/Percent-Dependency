character_set_filesystem   character_set_client
The file system character set. This variable is used to interpret string literals that refer to file names, such as in the LOAD DATA and SELECT ... INTO OUTFILE statements and the LOAD_FILE() function. Such file names are converted from character_set_client to character_set_filesystem before the file opening attempt occurs. The default value is binary, which means that no conversion occurs. For systems on which multibyte file names are permitted, a different value may be more appropriate. For example, if the system represents file names using UTF8, set character_set_filesystem to 'utf8mb4'. As of MySQL 8.0.14, setting the session value of this system variable is a restricted operation. The session user must have privileges sufficient to set restricted session variables. See Section\xc2\xa05.1.9.1, \xe2\x80\x9cSystem Variable Privileges\xe2\x80\x9d. "

flush	flush_time
If ON, the server flushes (synchronizes) all changes to disk after each SQL statement. Normally, MySQL does a write of all changes to disk only after each SQL statement and lets the operating system handle the synchronizing to disk. See Section\xc2\xa0B.3.3.3, \xe2\x80\x9cWhat to Do If MySQL Keeps Crashing\xe2\x80\x9d. This variable is set to ON if you start mysqld with the flush option. If flush is enabled, the value of flush_time does not matter and changes to flush_time have no effect on flush behavior. '

host_cache_size	 max_connections
The MySQL server maintains an inmemory host cache that contains client host name and IP address information and is used to avoid Domain Name System (DNS) lookups; see Section\xc2\xa05.1.12.3, \xe2\x80\x9cDNS Lookups and the Host Cache\xe2\x80\x9d. The host_cache_size variable controls the size of the host cache, as well as the size of the Performance Schema host_cache table that exposes the cache contents. Setting host_cache_size has these effects: Setting the size to 0 disables the host cache. With the cache disabled, the server performs a DNS lookup every time a client connects. Changing the size at runtime causes an implicit host cache flushing operation that clears the host cache, truncates the host_cache table, and unblocks any blocked hosts. The default value is autosized to 128, plus 1 for a value of max_connections up to 500, plus 1 for every increment of 20 over 500 in the max_connections value, capped to a limit of 2000. Using the skiphostcache option is similar to setting the host_cache_size system variable to 0, but host_cache_size is more flexible because it can also be used to resize, enable, and disable the host cache at runtime, not just at server startup. Starting the server with skiphostcache does not prevent runtime changes to the value of host_cache_size, but such changes have no effect and the cache is not reenabled even if host_cache_size is set larger than 0. Setting the host_cache_size system variable rather than the skiphostcache option is preferred for the reasons given in the previous paragraph. In addition, the skiphostcache option is deprecated and its removal is expected in a future version of MySQL; in MySQL 8.0.29 and later, using the option raises a warning. '

key_buffer_size	key_cache_block_size
Index blocks for MyISAM tables are buffered and are shared by all threads. key_buffer_size is the size of the buffer used for index blocks. The key buffer is also known as the key cache. The minimum permissible setting is 0, but you cannot set key_buffer_size to 0 dynamically. A setting of 0 drops the key cache, which is not permitted at runtime. Setting key_buffer_size to 0 is permitted only at startup, in which case the key cache is not initialized. Changing the key_buffer_size setting at runtime from a value of 0 to a permitted nonzero value initializes the key cache. key_buffer_size can be increased or decreased only in increments or multiples of 4096 bytes. Increasing or decreasing the setting by a nonconforming value produces a warning and truncates the setting to a conforming value. The maximum permissible setting for key_buffer_size is 4GB\xe2\x88\x921 on 32bit platforms. Larger values are permitted for 64bit platforms. The effective maximum size might be less, depending on your available physical RAM and perprocess RAM limits imposed by your operating system or hardware platform. The value of this variable indicates the amount of memory requested. Internally, the server allocates as much memory as possible up to this amount, but the actual allocation might be less. You can increase the value to get better index handling for all reads and multiple writes; on a system whose primary function is to run MySQL using the MyISAM storage engine, 25% of the machine's total memory is an acceptable value for this variable. However, you should be aware that, if you make the value too large (for example, more than 50% of the machine's total memory), your system might start to page and become extremely slow. This is because MySQL relies on the operating system to perform file system caching for data reads, so you must leave some room for the file system cache. You should also consider the memory requirements of any other storage engines that you may be using in addition to MyISAM. For even more speed when writing many rows at the same time, use LOCK TABLES. See Section\xc2\xa08.2.5.1, \xe2\x80\x9cOptimizing INSERT Statements\xe2\x80\x9d. You can check the performance of the key buffer by issuing a SHOW STATUS statement and examining the Key_read_requests, Key_reads, Key_write_requests, and Key_writes status variables. (See Section\xc2\xa013.7.7, \xe2\x80\x9cSHOW Statements\xe2\x80\x9d.) The Key_reads/Key_read_requests ratio should normally be less than 0.01. The Key_writes/Key_write_requests ratio is usually near 1 if you are using mostly updates and deletes, but might be much smaller if you tend to do updates that affect many rows at the same time or if you are using the DELAY_KEY_WRITE table option. The fraction of the key buffer in use can be determined using key_buffer_size in conjunction with the Key_blocks_unused status variable and the buffer block size, which is available from the key_cache_block_size system variable: This value is an approximation because some space in the key buffer is allocated internally for administrative structures. Factors that influence the amount of overhead for these structures include block size and pointer size. As block size increases, the percentage of the key buffer lost to overhead tends to decrease. Larger blocks results in a smaller number of read operations (because more keys are obtained per read), but conversely an increase in reads of keys that are not examined (if not all keys in a block are relevant to a query). It is possible to create multiple MyISAM key caches. The size limit of 4GB applies to each cache individually, not as a group. See Section\xc2\xa08.10.2, \xe2\x80\x9cThe MyISAM Key Cache\xe2\x80\x9d. "

max_allowed_packet net_buffer_length
The maximum size of one packet or any generated/intermediate string, or any parameter sent by the mysql_stmt_send_long_data() C API function. The default is 64MB. The packet message buffer is initialized to net_buffer_length bytes, but can grow up to max_allowed_packet bytes when needed. This value by default is small, to catch large (possibly incorrect) packets. You must increase this value if you are using large BLOB columns or long strings. It should be as big as the largest BLOB you want to use. The protocol limit for max_allowed_packet is 1GB. The value should be a multiple of 1024; nonmultiples are rounded down to the nearest multiple. When you change the message buffer size by changing the value of the max_allowed_packet variable, you should also change the buffer size on the client side if your client program permits it. The default max_allowed_packet value built in to the client library is 1GB, but individual client programs might override this. For example, mysql and mysqldump have defaults of 16MB and 24MB, respectively. They also enable you to change the clientside value by setting max_allowed_packet on the command line or in an option file. The session value of this variable is read only. The client can receive up to as many bytes as the session value. However, the server does not send to the client more bytes than the current global max_allowed_packet value. (The global value could be less than the session value if the global value is changed after the client connects.) '

max_connect_errors  flush
After max_connect_errors successive connection requests from a host are interrupted without a successful connection, the server blocks that host from further connections. If a connection from a host is established successfully within fewer than max_connect_errors attempts after a previous connection was interrupted, the error count for the host is cleared to zero. To unblock blocked hosts, flush the host cache; see Flushing the Host Cache. '

max_connections	 open_files_limit
The maximum permitted number of simultaneous client connections. The maximum effective value is the lesser of the effective value of open_files_limit 810, and the value actually set for max_connections. For more information, see Section\xc2\xa05.1.12.1, \xe2\x80\x9cConnection Interfaces\xe2\x80\x9d. '

max_heap_table_size	tmp_table_size
This variable sets the maximum size to which usercreated MEMORY tables are permitted to grow. The value of the variable is used to calculate MEMORY table MAX_ROWS values. The block size is 1024. A value that is not an exact multiple of the block size is rounded down to the next lower multiple of the block size by MySQL Server before storing the value for the system variable. The parser allows values up to the maximum unsigned integer value for the platform (4294967295 or 232\xe2\x88\x921 for a 32bit system, 18446744073709551615 or 264\xe2\x88\x921 for a 64bit system) but the actual maximum is a block size lower. Setting this variable has no effect on any existing MEMORY table, unless the table is recreated with a statement such as CREATE TABLE or altered with ALTER TABLE or TRUNCATE TABLE. A server restart also sets the maximum size of existing MEMORY tables to the global max_heap_table_size value. This variable is also used in conjunction with tmp_table_size to limit the size of internal inmemory tables. See Section\xc2\xa08.4.4, \xe2\x80\x9cInternal Temporary Table Use in MySQL\xe2\x80\x9d. max_heap_table_size is not replicated. See Section\xc2\xa017.5.1.21, \xe2\x80\x9cReplication and MEMORY Tables\xe2\x80\x9d, and Section\xc2\xa017.5.1.39, \xe2\x80\x9cReplication and Variables\xe2\x80\x9d, for more information. '

max_join_size	sql_big_selects
As of MySQL 8.0.31, this represents a limit on the maximum number of row accesses in base tables made by a join. If the server's estimate indicates that a greater number of rows than max_join_size must be read from the base tables, the statement is rejected with an error. MySQL 8.0.30 and earlier: Do not permit statements that probably need to examine more than max_join_size rows (for singletable statements) or row combinations (for multipletable statements) or that are likely to do more than max_join_size disk seeks. By setting this value, you can catch statements where keys are not used properly and that would probably take a long time. Set it if your users tend to perform joins that lack a WHERE clause, that take a long time, or that return millions of rows. For more information, see Using SafeUpdates Mode (safeupdates). Regardless of MySQL release version, setting this variable to a value other than DEFAULT resets the value of sql_big_selects to 0. If you set the sql_big_selects value again, the max_join_size variable is ignored. "

max_sp_recursion_depth	thread_stack
The number of times that any given stored procedure may be called recursively. The default value for this option is 0, which completely disables recursion in stored procedures. The maximum value is 255. Stored procedure recursion increases the demand on thread stack space. If you increase the value of max_sp_recursion_depth, it may be necessary to increase thread stack size by increasing the value of thread_stack at server startup. '
